---
title: "Architecture"
description: "This page talks about the general architecture of Wirekite, the various components that comprise it and functions, limitations of those components. For a more detailed architecture please check the Implementation page.  "
---

## ![](/images/SimpleArchitecture.svg)

## Flow

Simply speaking wirekite sits in the middle of source and target databases, extracts "stuff" from source databases, moves it to relevant middle ware storage, and loads it onto the target databases. Thus essentially it has 3 components as explained next.

## Entities&#x20;

Wirekite extracts and loads 3 entities from the source database into the target database and in the following order.

<Steps>
  <Step title="Schema">
    Schema essentially refers to the "structure" of the data. It constitutes the definition of tables, the columns, their datatypes, any other properties like primary keys, unique keys, foreign keys, constraints etc. Thus the Schema files contain create table statement. This is a one time task so that we have empty tables in the target database that can receive the incoming data in the next steps.
  </Step>

  <Step title="Data">
    Data at this stage refers to the initial dump of data from the source. Usually this means multiple tables which can also be large in size (TBs/PBs). Thus this is essentially the heavy weight bits of the source database that needs to be loaded onto the target database. This is also a one time process. This is usually done from a replica of the source database, since the live source database is live and is serving production applications. Wirekite uses a proprietary format to store data which is only interpret-able by wirekite components. Also note that this process has a high degrees of parallelism since data can be loaded onto the target in any order.
  </Step>

  <Step title="Change">
    Change refers to the constant "changes" that happen to the source database. Typically this means Inserts, Updates and Deletes. Note that this happens infinitely and Wirekite establishes a pipeline from the source to the target so that target is kept up to date to the source. Thus this is an ongoing process. Also note that this is usually a single threaded process since the transaction that are happening on source need to be executed on the target in the exact same order.
  </Step>
</Steps>

## Components

Wirekite essentially has 3 components which are essentially the actions that are taken on the entities listed above.&#x20;

<Steps>
  <Step title="Extractor">
    This is the component that extracts schema, data and change from the source database. Extractors are only aware of sources and are completely agnostic to the next steps that follow after. Thus this component essentially "reads" from the source database to "writes" to the relevant storage.
  </Step>

  <Step title="Mover">
    This is the component that does the moving of the files from source database to target. Note that this component is agnostic to the contents of the files and does not read/write the, but essentially just moves the blocks from one storage location to another.
  </Step>

  <Step title="Loader">
    This is the component that reads the file which are moved by the mover and "loads" them onto the target databases. Loaders work on schema, data and change files. Loaders essentially read the files and translate them to corresponding database language statements and execute those statements on the database.
  </Step>
</Steps>

### Putting It Together



Now that we have 3 entities -- schema, data and change -- and we have 3 components -- extractor, mover and loader -- we have to execute the components on he entities in a specific order.&#x20;

The following sequence outlines how all the components on the various entities. For more details please go to the Implementation section.&#x20;



<Steps>
  
  <Step title="Schema">
    <Steps>
      <Step>Extractor</Step>    
      <Step>Loader</Step>    
    </Steps>    
  </Step>

  <Step title="Step 2">
  </Step>

</Steps>











<AccordionGroup>
  <Accordion icon="github" title="Clone your docs locally">
    During the onboarding process, we created a repository on your Github with
    your docs content. You can find this repository on our
    [dashboard](https://dashboard.mintlify.com). To clone the repository
    locally, follow these
    [instructions](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository)
    in your terminal.
  </Accordion>

  <Accordion icon="rectangle-terminal" title="Preview changes">
    Previewing helps you make sure your changes look as intended. We built a
    command line interface to render these changes locally. 1. Install the
    [Mintlify CLI](https://www.npmjs.com/package/mintlify) to preview the
    documentation changes locally with this command: `npm i -g mintlify`
    2\. Run the following command at the root of your documentation (where
    `mint.json` is): `mintlify dev`
  </Accordion>
</AccordionGroup>

### Deploy your changes

<AccordionGroup>
  <Accordion icon="message-bot" title="Install our Github app">
    Our Github app automatically deploys your changes to your docs site, so you
    don't need to manage deployments yourself. You can find the link to install on
    your [dashboard](https://dashboard.mintlify.com). Once the bot has been
    successfully installed, there should be a check mark next to the commit hash
    of the repo.
  </Accordion>

  <Accordion icon="rocket" title="Push your changes">
    [Commit and push your changes to
    Git](https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository#about-git-push)
    for your changes to update in your docs site. If you push and don't see that
    the Github app successfully deployed your changes, you can also manually
    update your docs through our [dashboard](https://dashboard.mintlify.com).
  </Accordion>
</AccordionGroup>

## Update your docs

Add content directly in your files with MDX syntax and React components. You can use any of our components, or even build your own.

<CardGroup>
  <Card title="Style Your Docs" icon="paintbrush" href="/settings/global">
    Add flair to your docs with personalized branding.
  </Card>

  <Card title="Add API Endpoints" icon="square-code" href="/api-playground/configuration">
    Implement your OpenAPI spec and enable API user interaction.
  </Card>

  <Card title="Integrate Analytics" icon="chart-mixed" href="/analytics/supported-integrations">
    Draw insights from user interactions with your documentation.
  </Card>

  <Card title="Host on a Custom Domain" icon="browser" href="/settings/custom-domain/subdomain">
    Keep your docs on your own website's subdomain.
  </Card>
</CardGroup>